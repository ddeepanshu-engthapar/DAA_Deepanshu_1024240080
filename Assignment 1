#include <iostream>
using namespace std;

int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}





int main() {
    int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 23;

    int result = binarySearch(arr, n, target);
    if (result != -1)
        cout << "Element found at index: " << result;
    else
        cout << "Element not found";
}





#include <iostream>
using namespace std;

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = (l + r) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;
}






int main() {
    int arr1[] = {12, 11, 13, 5, 6, 7};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);

    int arr2[] = {38, 27, 43, 3, 9, 82, 10};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);

    mergeSort(arr1, 0, n1 - 1);
    mergeSort(arr2, 0, n2 - 1);

    cout << "Sorted arr1: "; printArray(arr1, n1);
    cout << "Sorted arr2: "; printArray(arr2, n2);
}






#include <iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}






int main() {
    int arr[] = {4, 2, 6, 9, 2};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}







#include <iostream>
#include <climits>
using namespace std;

int maxCrossingSum(int arr[], int l, int m, int h) {
    int sum = 0, left_sum = INT_MIN;
    for (int i = m; i >= l; i--) {
        sum += arr[i];
        left_sum = max(left_sum, sum);
    }

    sum = 0;
    int right_sum = INT_MIN;
    for (int i = m + 1; i <= h; i++) {
        sum += arr[i];
        right_sum = max(right_sum, sum);
    }

    return left_sum + right_sum;
}

int maxSubArraySum(int arr[], int l, int h) {
    if (l == h) return arr[l];

    int m = (l + h) / 2;

    return max({
        maxSubArraySum(arr, l, m),
        maxSubArraySum(arr, m + 1, h),
        maxCrossingSum(arr, l, m, h)
    });
}






int main() {
    int arr[] = {-2, -5, 6, -2, -3, 1, 5, -6};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Maximum Subarray Sum = " << maxSubArraySum(arr, 0, n - 1);
}






#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>
using namespace std;

struct Point { int x, y; };

float dist(Point p1, Point p2) {
    return sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));
}

float bruteForce(vector<Point>& P) {
    float minDist = 1e9;
    for (int i = 0; i < P.size(); i++)
        for (int j = i + 1; j < P.size(); j++)
            minDist = min(minDist, dist(P[i], P[j]));
    return minDist;
}






int main() {
    vector<Point> points = {
        {9,2},{15,3},{5,1},{12,14},{7,2},{4,7},{16,5},
        {3,3},{10,5},{6,4},{14,6},{8,6},{11,1},{13,2}
    };

    cout << "Minimum distance: " << bruteForce(points);
}
